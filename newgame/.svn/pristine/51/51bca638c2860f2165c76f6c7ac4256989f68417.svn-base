<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:aop="http://www.springframework.org/schema/aop" 
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:cache="http://www.springframework.org/schema/cache"  
	xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-4.0.xsd 
http://www.springframework.org/schema/tx 
http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
http://www.springframework.org/schema/aop 
http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context-4.0.xsd
http://www.springframework.org/schema/cache 
http://www.springframework.org/schema/cache/spring-cache.xsd"
>
	<!--统一的dataSource-->
	<bean id="dynamicDataSource" class="web.game.dynamicdatasource.DynamicDataSource" >
	    <property name="targetDataSources">
	        <map key-type="java.lang.String">
	            <!--通过不同的key决定用哪个dataSource-->
	            <entry value-ref="dataSource" key="dataSource"></entry>
	            <entry value-ref="dataSource2" key="mssqlDataSource"></entry>
	        </map>
	    </property>
	    <!--设置默认的dataSource-->
	    <property name="defaultTargetDataSource" ref="dataSource">
	    </property>
	</bean>

	<!-- 阿里德鲁伊 配置数据源 -->
	<bean name="commondataSource" class="com.alibaba.druid.pool.DruidDataSource"
		init-method="init" destroy-method="close">

		<property name="url"   value="${jdbc_url2}" />
		<property name="username" value="${jdbc_username2}" />
		<property name="password" value="${jdbc_password2}" />

		<!-- 初始化连接大小 -->
		<property name="initialSize" value="0" />
		<!-- 连接池最大使用连接数量 -->
		<property name="maxActive" value="50" />
		<!-- 连接池最大空闲 -->
		<property name="maxIdle" value="20" />
		<!-- 连接池最小空闲 -->
		<property name="minIdle" value="0" />
		<!-- 获取连接最大等待时间 -->
		<property name="maxWait" value="60000" />
		<!-- 指明是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个-->
		<property name="testOnBorrow" value="true" />
		<!-- 指明是否在归还到池中前进行检验-->
		<property name="testOnReturn" value="false" />
		<!-- 指明连接是否被空闲连接回收器(如果有)进行检验.如果检测失败,则连接将被从池中去除-->
		<property name="testWhileIdle" value="true" />
		<!-- SQL查询,用来验证从连接池取出的连接,在将连接返回给调用者之前.如果指定,则查询必须是一个SQL SELECT并且必须返回至少一行记录 -->
		<property name="validationQuery" value="SELECT 1" />  

		<!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
		<property name="timeBetweenEvictionRunsMillis" value="60000" />
		<!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->
		<property name="minEvictableIdleTimeMillis" value="25200000" />

		<!-- 打开removeAbandoned功能 -->
		<property name="removeAbandoned" value="true" />
		<!-- 1800秒，也就是30分钟 -->
		<property name="removeAbandonedTimeout" value="1800" />
		<!-- 关闭abanded连接时输出错误日志 -->
		<property name="logAbandoned" value="true" />

		<!-- 监控数据库 -->
		<!-- <property name="filters" value="stat" /> -->
		<property name="filters" value="mergeStat" />
	</bean>
	
	<!-- 阿里德鲁伊 配置数据源 -->
	<bean name="dataSource" parent="commondataSource">
		<property name="url"   value="${jdbc_url}" />
		<property name="username" value="${jdbc_username}" />
		<property name="password" value="${jdbc_password}" />
	</bean>
	
	<bean name="dataSource2" parent="commondataSource">
		<property name="url"   value="${jdbc_url2}" />
		<property name="username" value="${jdbc_username2}" />
		<property name="password" value="${jdbc_password2}" />
	</bean>


	<!-- myBatis文件 -->
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dynamicDataSource" />
		<!-- 扫描mybatisConfig.xml里的配置 -->
		<property name="configLocation" value="classpath:../spring_config/mybatis-config.xml" />
		<!-- 省掉mybatisConfig.xml里的手工配置mapper映射 -->
		<property name="mapperLocations" value="classpath:../mapper/*.xml" />
		<!-- <property name="typeAliasesPackage" value="web.webSocket.pojo"></property> -->
	</bean>
	
	
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
	<property name="basePackage" value="web.game.mapper" />
	<!-- 
	value="sqlSessionFactory":注入的是 sqlSessionFactory
	name="sqlSessionFactoryBeanName"是将sqlSessionFactory注入到org.java.mapper包里的所有mapper里面，所以是根据sqlSessionFactoryBeanName 
	-->
	<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"></property>
	</bean>
	
	
	    <!-- 缓存配置(两种) -->    
    <!-- 启用缓存注解功能(请将其配置在Spring主配置文件中) -->    
    <cache:annotation-driven cache-manager="cacheManager"/> 
    <!-- Spring自己的基于java.util.concurrent.ConcurrentHashMap实现的缓存管理器(该功能是从Spring3.1开始提供的) -->    
    <!--     
    <bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager">    
        <property name="caches">    
            <set>    
                <bean name="myCache" class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean"/>    
            </set>    
        </property>    
    </bean>    
     -->    
    <!-- 若只想使用Spring自身提供的缓存器,则注释掉下面的两个关于Ehcache配置的bean,并启用上面的SimpleCacheManager即可 -->    
<!--     Spring提供的基于的Ehcache实现的缓存管理器      -->
    <bean id="cacheManagerFactory" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">    
      <property name="configLocation" value="classpath:../spring_config/ehcache.xml"/> 
       <!--  <property name="configLocation" value="ehcache.xml"/> -->
        <property name="shared" value="true" />  
    </bean>    
    <bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">    
        <property name="cacheManager" ref="cacheManagerFactory"/>    
    </bean>
	
	
	


	<!-- 配置映射器由Spring容器进行管理，在Service组件中进行依赖注入 -->
	<bean class="tk.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="basePackage" value="web.game.mapper" />
		<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
		<property name="properties">
			<value>
				mappers=tk.mybatis.mapper.common.Mapper
			</value>
		</property>
	</bean>


	<!-- 配置事务管理器 -->
	<bean id="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dynamicDataSource" />
	</bean>

	<!-- 注解方式配置事物 -->
	<!-- <tx:annotation-driven transaction-manager="transactionManager" /> -->

	<!-- 拦截器方式配置事物 -->
	<tx:advice id="transactionAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="save*" propagation="REQUIRED" />
			<tx:method name="delete*" propagation="REQUIRED" />
			<tx:method name="update*" propagation="REQUIRED" />
			<tx:method name="*" propagation="NEVER" read-only="true" />
		</tx:attributes>
	</tx:advice>
<!-- 	<aop:config>
		<aop:pointcut id="transactionPointcut"
			expression="execution(* org.team01.ssm.service.impl.*.*(..))" />
		<aop:advisor pointcut-ref="transactionPointcut"
			advice-ref="transactionAdvice" />
	</aop:config> -->

</beans>